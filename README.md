# Simple Interpreter

A C++20-based interpreter for a custom programming language built from the ground up. This project implements a complete pipeline from tokenization through AST generation to bytecode execution, featuring a register-based virtual machine architecture.

## Project Overview

This interpreter is designed as an educational tool demonstrating core compiler and interpreter concepts. It processes a custom scripting language (`.sl` files) with support for basic programming constructs including variables, control flow, and functions.

### Architecture

The interpreter follows a traditional multi-stage architecture:

1. **Tokenizer** (`tokenizer.h/cpp`) - Lexical analysis converting source code into tokens
2. **Parser** (`parser.h/cpp`) - Syntax analysis building an Abstract Syntax Tree (AST)
3. **AST** (`ast.h`) - Intermediate representation with code generation capabilities  
4. **Code Generator** - Converts AST nodes into bytecode instructions
5. **Interpreter** (`interpreter.h/cpp`) - Register-based virtual machine executing bytecode
6. **Symbol Table** (`symbol_table.h`) - Manages variable and function scope

### Key Components

- **Instructions** (`instructions.h/cpp`) - Bytecode instruction set for the virtual machine
- **Expressions** (`expr.h/cpp`) - AST nodes for arithmetic and logical expressions
- **Statements** (`statement.h/cpp`) - AST nodes for control flow and declarations
- **Functions** (`function.h/cpp`) - Function definition and call handling
- **Register Allocator** (`optimizers/register_alloc.hpp/cpp`) - Optimization component (work in progress)

### Supported Features
- **Data Types**: Double-precision floating point numbers
- **Variables**: Immutable declarations (`let`) and mutable assignments (`mut`)
- **Arithmetic**: Standard operators (+, -, *, /, %)
- **Control Flow**: 
  - If-else statements (else clause mandatory)
  - While loops
- **Functions**: Definition, calls, and single return statements
- **I/O**: Print statement for output
- **Scoping**: Two-level scope system (Global and Function)

### Current Limitations
- Single data type (double only)
- No for-loop support
- One return statement per function
- Mandatory else clauses
- Limited to two scope levels
- No arrays or complex data structures

## Getting Started

### Prerequisites
- C++20 compatible compiler (Clang++ recommended)
- CMake 3.27 or higher
- Make or similar build system

### Building the Project

```bash
# Clone the repository
git clone <repository-url>
cd simple-interpreter

# Create build directory
mkdir build && cd build

# Configure with CMake
cmake ..

# Build the project
make
```

### Running the Interpreter

The interpreter supports three modes of operation:

#### Interactive Mode (REPL)
```bash
./run
```
Start an interactive session where you can type commands line by line:
```
>>> let x = 5;
>>> print(x);
5.000000
>>> exit
```

#### Debug Mode
```bash
./run --debug
```
Shows variable states after each command execution.

#### IR Mode (Intermediate Representation)
```bash
./run --ir
```
Displays the generated bytecode instructions instead of executing them.

#### File Execution
```bash
./run --file <filename.sl>
```
Execute a complete program from a `.sl` file.

### Example Programs

The `examples/` directory contains sample programs:
- `ex1.sl` - Basic variable operations
- `ex2.sl` - While loop demonstration
- `ex3.sl` - Function definitions and calls
- `ex4.sl` - Conditional statements
- `ex5.sl` - Complex nested structures

## Language Syntax

### Grammar Specification

```
program     := statement*
statement   := varDecl | assignment | ifStmt | whileStmt | functionDecl | printStmt
varDecl     := "let" IDENTIFIER "=" expression ";"
assignment  := "mut" IDENTIFIER "=" expression ";"
ifStmt      := "if" "(" expression ")" "{" statement* "}" "else" "{" statement* "}"
whileStmt   := "while" "(" expression ")" "{" statement* "}"
functionDecl:= "fn" IDENTIFIER "(" params? ")" "{" statement* "return" expression ";" "}"
printStmt   := "print" "(" expression ")" ";"
expression  := term (("+"|"-") term)*
term        := factor (("*"|"/"|"%") factor)*
factor      := NUMBER | IDENTIFIER | "(" expression ")" | functionCall
functionCall:= "call" IDENTIFIER "(" args? ")"
params      := IDENTIFIER ("," IDENTIFIER)*
args        := expression ("," expression)*
```

## Examples

### Declaring variables
```
let x = 5;
let y = x*5;
let z = x+y-5;
mut x = 11;
```

### If Conditions

```
let x = 5;

if ( x < 10) { mut x = x * 2; } else { mut x = x / 2; }

if( x < 10) { if (x > 5) { mut  x = x*2; } else { mut x = x * 4; } } else { mut x = x /2; }
```

### While loops
```
let x = 1;
while(x < 10) { mut x = x + 1; }

let i = 1;
while(i < 10) { if (x < 5) { mut x = x*2; } else { mut x = x/2; } mut i = i + 1; }

```

### Functions
```
fn double(x) { return x*2; }

let a = call double(2);

let b = call double(a);

fn add_doubles(x, y) { return call double(x) + call double(y); }

let x = call add_doubles(1, 2);
```

## Implementation Details

### Virtual Machine Architecture

The interpreter uses a register-based virtual machine with the following instruction set:

- **LOAD_CONST** - Load constant value into register
- **LOAD_VAR** - Load variable value into register
- **STORE_VAR** - Store register value in variable
- **BINARY_OP** - Perform operation on register values
- **JUMP** - Unconditional jump to instruction
- **JUMP_IF_FALSE** - Conditional jump based on register value
- **CALL** - Function call with parameter passing
- **RETURN** - Return from function with value
- **PRINT** - Output register value to console

### Memory Management

- Variables are stored in a symbol table with lexical scoping
- Function parameters and local variables use separate register allocation
- Automatic memory management for temporary values during expression evaluation

### Error Handling

The interpreter provides comprehensive error reporting for:
- Syntax errors during parsing
- Runtime errors (undefined variables, type mismatches)
- Function call errors (wrong parameter count, undefined functions)

### Testing

Run the test suite to verify interpreter functionality:
```bash
cd build
make test
# or run specific tests
./test/test_runner
```

## Project Structure

```
simple-interpreter/
├── app/                    # Main application entry point
│   └── main.cpp
├── includes/              # Header files
│   ├── ast.h             # Abstract Syntax Tree definitions
│   ├── expr.h            # Expression AST nodes
│   ├── function.h        # Function handling
│   ├── instructions.h    # VM instruction set
│   ├── interpreter.h     # Virtual machine interpreter
│   ├── parser.h          # Syntax parser
│   ├── statement.h       # Statement AST nodes
│   ├── symbol_table.h    # Variable and scope management
│   ├── tokenizer.h       # Lexical analyzer
│   ├── tokens.h          # Token definitions
│   └── optimizers/       # Optimization passes
│       └── register_alloc.hpp
├── src/                   # Implementation files
│   ├── expr.cpp
│   ├── function.cpp
│   ├── instructions.cpp
│   ├── interpreter.cpp
│   ├── parser.cpp
│   ├── statement.cpp
│   ├── tokenizer.cpp
│   └── optimizers/
│       └── register_alloc.cpp
├── examples/              # Sample programs
│   ├── ex1.sl - ex5.sl
├── test/                  # Unit tests
├── build/                 # Build artifacts
├── CMakeLists.txt        # Build configuration
└── README.md
```

## Future Enhancements

### Planned Features
- Array data structures and operations
- For-loop support  
- String data type and operations
- Multiple return statements per function
- Enhanced error messages with line numbers
- Standard library functions
- File I/O operations

### Potential Optimizations
- Register allocation (partially implemented)
- Constant folding
- Dead code elimination
- Tail call optimization

## Contributing

This project serves as an educational example of interpreter implementation. Feel free to:
- Report issues or bugs
- Suggest improvements to the language design
- Contribute additional example programs
- Implement planned features

## Development

### Code Style
- C++20 standard features
- Clang-format configuration included
- Header-only interfaces where possible
- RAII for resource management

### Build Configuration
- CMake-based build system
- Compiler flags: `-Wall -Wno-sign-compare -Wextra -Wpedantic -O2`
- Clang++ as the default compiler
- Compile commands export for IDE integration
